### jQuery-реализация: подключение на проект ###

#### Чеклист ####
Для использования svarx-валидации необходимо выполнить следующие действия:

  * подключить jQuery 1.3.2 или более позднюю
  * подключить сам плагин jquery.svarx.js
  * подключить хотя бы один плагин, реализующий визуализацию ошибок на странице (например, svarx.methods.alerts.js)
  * если используются кастомные методы валидации, подключить дополнительные js-файлы с реализацией этих методов

#### Инициализация в js ####
В настоящий момент jquery.svarx.js и плагин svarx.methods.alerts.js можно взять из этого git-репозитория.

Инициализация происходит вызовом следующего метода:

```javascript
$('form').svarx({
    // имя метода визуализации ошибок.
    // если у вас подключен только 1 метод визуализации, можно его не указывать,
    // плагин сам выберет его.
    method: 'messages',

    // URL для загрузки xml-файла со SVARX-правилами.
    // Обратите внимание: используется обычный XMLHttpRequest,
    // все кроссдоменные ограничения в силе!
    svarxURL: '/путь/к/svarx-файлу.xml',
    
    // альтернативный вариант — передать в svarx-плагин XML-дерево со SVARX-валидацией (готовый XMLDocument, а не строку)
    // svarxXML: xmlDoc,
    
    // На какое событие вешать валидацию.
    // По умолчанию это submit. События слушаются на элементе формы (form).
    // Можно указать несколько событий через пробел, в т.ч. можно использовать пользовательские события.
    bindTo: 'submit',

    // Если вы точно знаете, что состав элементов формы не будет меняться, вы можете указать ключ imnmutable,
    // это сильно ускорит работу плагина, т.к. позволит кэшировать все выборки элементов формы.
    immutable: true,

    // Если нужно использовать для валидации только часть SVARX-правил для валидации и/или препроцессинга,
    // можно отметить внутри SVARX-документа нужные правила (или блоки правил) с помощью атрибута id,
    // и указать этот id в соответствующем параметре.
    // По умолчанию, разумеется, используются все правила валидации и все правила препроцессинга.
    // Эта техника позволяет хранить в одном файле правила для нескольких форм.
    //
    // Также, можно указывать эти id динамически во время работы, см. ниже раздел
    // «Динамическая валидация с использованием выборочных правил».
    // не указывайте несуществующие id, это приведёт к тому, что валидация или препроцессинг
    // будут использовать пустой набор правил.
    validateBlockId: 'unique-id',
    preprocessBlockId: 'unique-id',
    
    // Расширение свойств для объкта, который передаётся в jQuery.ajax() при запросе внешнего svarx-файла.
    // Не следует использовать св-во url для назначения пути к svarx-файлу, это не приведёт к ожидаемой цели;
    // вместо этого при необходимости используйте параметр svarxURL самого метода .svarx() (см. выше).
    // Нельзя переопределять колбэки success и error, это нарушит работу плагина.
    jQueryAjax: {
        // параметры, которые можно использовать в jQuery.ajax, например:
        // cache: false,
        // async: false
        // и т.п.
    }
});

```

Как легко догадаться, инициализация асинхронная (синхронной она будет в случае передачи готового xml-дерева).
При этом проверка будет проассоциирована со всеми формами, которые вернёт селектор, указанный в родительском jQuery-объекте.
Сам метод вернёт jQuery-объект, полученный на входе, никак его не изменяя.

#### Альтернатива параметру immutable ####

Использование параметра **immutable: true** сильно ускоряет работу плагина за счёт агрессивного кэширования.
Как быть, если состав элементов формы всё же меняется, но редко и в заранее известные моменты?

В этом случае всё равно можно использовать параметр **immutable: true**, но при изменении формы нужно вызывать на ней кастомное событие **svarxformupdate**:

```javascript
$('form').trigger('svarxformupdate');
```

Такой вызов сбросит все накопленные внутренние кеши и начнёт накапливать их заново.

#### Как сбросить все валидационные правила? ####

Если в какой-то момент надо перманентно «отвязать» валидацию от формы, вызовите метод `.svarx` с пустым объектом в качестве аргумента:

```javascript
$('form').svarx({});  // снять все навешенные на эту форму обработчики
```

#### Динамическая валидация с использованием выборочных правил ####
Иногда бывает необходимо динамически переопределить множество правил, используемых для валидации.
К примеру, пока пользователь заполняет важную часть формы, вы можете ограничить проверку только нужными
полями, а остальные игнорировать. То же самое касается и правил препроцессинга: если мы валидируем только несколько полей, логично не вызывать препроцессинг для остальной формы.

Использование параметров validateBlockId или preprocessBlockId решает в точности ту же задачу, но определяет подмножество правил раз и навсегда.
Вместо того, чтобы вновь и вновь назначать на форму SVARX-обработчик с разными id, можно определять эти id динамически, если событие, инициирующее валидацию, вызывается вами в коде с помощью jQuery-метода **.trigger()**.
Обычно, для этого удобно назначать валидацию на пользовательское событие (параметр bindTo), а затем делать следующее:

```javascript
$('form').trigger(
    'myValidationEvent',
    [
        param1,
        param2,
        {
            validationBlockId: 'unique-id',
            preprocessBlockId: 'unique-id'
        }
    ]
);
```

Объект с ключами **validationBlockId** и/или **preprocessBlockId** должен указываться **последним** в списке аргументов.
В этом случае указанные id будут использованы только при обработке данного события, все остальные случаи будут использовать обычный набор правил.
Данный динамический синтаксис переопределяет опции **validateBlockId** и **preprocessBlockId**, если они были указаны при инициализации SVARX, но не перезаписывает их, т.е. переопределение - только **динамическое**.
Не указывайте id, которых нет в SVARX-документе, это рассматривается как аналог использования пустого набора правил.
